#!/usr/bin/env python3
"""
new_script.py

Simple script factory: creates a new Python script with a standard, labeled skeleton.

Usage:
    python3 scripts/new_script.py my_tool "Short description of what this script does"

It will create: my_tool.py in the current directory (or in a target folder if you pass --dir).
"""

import argparse
import os
import textwrap
from datetime import datetime


def make_script_content(name: str, description: str) -> str:
    """Return the text content for a new Python script."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    module_doc = textwrap.fill(description, width=76)

    return f"""#!/usr/bin/env python3
\"\"\"{name}.py

{module_doc}

Generated by new_script.py on {timestamp}.
\"\"\"

# === PART 1: IMPORTS & SETUP ===

import argparse
import logging
import sys


# === PART 2: CONFIG & CONSTANTS ===

# TODO: add any module-level constants or settings here
# EXAMPLE:
# DEFAULT_TIMEOUT = 5.0


# === PART 3: CORE FUNCTIONS ===

def setup_logging(verbose: bool = False) -> None:
    \"\"\"Configure basic logging.\"\"\"
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def parse_args(argv=None):
    \"\"\"Parse command-line arguments.\"\"\"
    parser = argparse.ArgumentParser(
        prog="{name}",
        description="{description}",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose (DEBUG) logging",
    )
    # TODO: add more CLI arguments here as needed
    return parser.parse_args(argv)


def run(args) -> int:
    \"\"\"Core logic for {name}. Return an int exit code.\"\"\"
    logging.info("Starting {name}...")
    # TODO: implement your core logic here
    logging.info("Finished {name}.")
    return 0


# === PART 4: CLI & MAIN ENTRYPOINT ===

def main(argv=None) -> int:
    \"\"\"Main entry point wrapper.\"\"\"
    args = parse_args(argv)
    setup_logging(verbose=args.verbose)
    return run(args)


if __name__ == "__main__":
    raise SystemExit(main())
"""


def main(argv=None) -> int:
    parser = argparse.ArgumentParser(
        prog="new_script",
        description="Generate a new Python script with a standard, labeled skeleton.",
    )
    parser.add_argument(
        "name",
        help="Base name for the new script (e.g., my_tool -> my_tool.py)",
    )
    parser.add_argument(
        "description",
        help="Short description for the script's docstring.",
    )
    parser.add_argument(
        "--dir",
        default=".",
        help="Target directory to create the script in (default: current directory).",
    )

    args = parser.parse_args(argv)

    # Ensure directory exists
    target_dir = os.path.abspath(args.dir)
    os.makedirs(target_dir, exist_ok=True)

    # Build file path
    base_name = args.name
    if not base_name.endswith(".py"):
        base_name += ".py"

    target_path = os.path.join(target_dir, base_name)

    if os.path.exists(target_path):
        print(f"ERROR: {target_path} already exists.", file=sys.stderr)
        return 1

    # Write file
    content = make_script_content(args.name, args.description)
    with open(target_path, "w", encoding="utf-8") as f:
        f.write(content)

    # Make it executable (Unix-like systems)
    try:
        current_mode = os.stat(target_path).st_mode
        os.chmod(target_path, current_mode | 0o111)
    except Exception:
        # If chmod fails (e.g. on some platforms), ignore
        pass

    print(f"Created new script at: {target_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())